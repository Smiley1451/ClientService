spring.application.name=ClientService
# Service Port
server.port=8082

# Application Name


# PostgreSQL R2DBC (Reactive) Connection
spring.r2dbc.url=r2dbc:postgresql://neondb_owner:npg_4dVw9QCKIDYP@ep-spring-heart-ahg404z0-pooler.c-3.us-east-1.aws.neon.tech/neondb?sslmode=require
spring.r2dbc.username=neondb_owner
spring.r2dbc.password=npg_4dVw9QCKIDYP

spring.r2dbc.pool.enabled=true
spring.r2dbc.pool.initial-size=5
spring.r2dbc.pool.max-size=10
spring.r2dbc.pool.max-idle-time=30m
spring.flyway.enabled=true
spring.flyway.url=jdbc:postgresql://ep-spring-heart-ahg404z0.c-3.us-east-1.aws.neon.tech/neondb?sslmode=require
spring.flyway.user=neondb_owner
spring.flyway.password=npg_4dVw9QCKIDYP
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true


# Kafka Consumer Configuration
# This is all you need for the consumer
spring.kafka.consumer.bootstrap-servers=localhost:29092

# Your KafkaConfig.java needs a KafkaTemplate for the Dead Letter Queue.
# Spring Boot will create one for you automatically with these properties:
spring.kafka.producer.bootstrap-servers=localhost:29092
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer


kafka.topics.user-created=user.created
# --- JWT Security Configuration (NEW) ---
# This must point to your AuthService (e.g., Keycloak)
# Spring Security uses this to auto-discover the public keys for JWT validation
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8085

# --- DEVELOPMENT SETTINGS ---

# Disables the Eureka client
eureka.client.enabled=false

groq.api.model=llama-3.1-8b-instant

cloudinary.cloud_name=djtuwbdtx
cloudinary.api_key=163855155464785
cloudinary.api_secret=SDLj8I1ov_N2FEdGohZLoS7Ijok

# Disables the Kafka auto-configuration
#spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration
